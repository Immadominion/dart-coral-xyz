import '../idl/idl.dart';
import '../coder/discriminator_computer.dart';
import '../types/public_key.dart';

/// Comprehensive event definition system matching TypeScript's event metadata handling
class EventDefinition {
  /// Event name
  final String name;

  /// Event documentation
  final List<String>? docs;

  /// Event fields with complete type information
  final List<EventFieldDefinition> fields;

  /// Event discriminator for identification
  final List<int>? discriminator;

  /// Event metadata for additional validation and processing
  final EventMetadata metadata;

  /// Event validation rules
  final EventValidationRules validationRules;

  /// Event inheritance information
  final EventInheritanceInfo? inheritanceInfo;

  /// Event versioning information
  final EventVersionInfo? versionInfo;

  const EventDefinition({
    required this.name,
    this.docs,
    required this.fields,
    this.discriminator,
    required this.metadata,
    required this.validationRules,
    this.inheritanceInfo,
    this.versionInfo,
  });

  /// Create EventDefinition from IDL
  factory EventDefinition.fromIdl(IdlEvent idlEvent, {
    Map<String, IdlTypeDef>? customTypes,
    EventDefinitionConfig? config,
  }) {
    config ??= EventDefinitionConfig.defaultConfig();
    
    // Parse fields with type information
    final fields = idlEvent.fields.map((field) => 
      EventFieldDefinition.fromIdlField(field, customTypes: customTypes)
    ).toList();

    // Generate discriminator if not provided
    final discriminator = idlEvent.discriminator ?? 
      (config.autoGenerateDiscriminator 
        ? DiscriminatorComputer.computeEventDiscriminator(idlEvent.name)
        : null);

    // Create metadata
    final metadata = EventMetadata(
      totalFields: fields.length,
      hasOptionalFields: fields.any((f) => f.isOptional),
      hasNestedStructures: fields.any((f) => f.typeInfo.isComplex),
      estimatedSize: _calculateEstimatedSize(fields),
      complexity: _calculateComplexity(fields),
      tags: _extractTags(idlEvent.docs),
    );

    // Create validation rules
    final validationRules = EventValidationRules.fromFields(fields, config: config);

    // Parse inheritance info from docs
    final inheritanceInfo = _parseInheritanceInfo(idlEvent.docs);

    // Parse version info from docs
    final versionInfo = _parseVersionInfo(idlEvent.docs);

    return EventDefinition(
      name: idlEvent.name,
      docs: idlEvent.docs,
      fields: fields,
      discriminator: discriminator,
      metadata: metadata,
      validationRules: validationRules,
      inheritanceInfo: inheritanceInfo,
      versionInfo: versionInfo,
    );
  }

  /// Validate event data against definition
  EventValidationResult validateEventData(Map<String, dynamic> eventData) {
    final errors = <String>[];
    final warnings = <String>[];

    // Validate required fields
    for (final field in fields) {
      if (field.isRequired && !eventData.containsKey(field.name)) {
        errors.add('Missing required field: ${field.name}');
      }
    }

    // Validate field types and constraints
    for (final entry in eventData.entries) {
      final fieldName = entry.key;
      final fieldValue = entry.value;
      
      final fieldDef = fields.where((f) => f.name == fieldName).firstOrNull;
      if (fieldDef == null) {
        warnings.add('Unknown field: $fieldName');
        continue;
      }

      final fieldValidation = fieldDef.validateValue(fieldValue);
      if (!fieldValidation.isValid) {
        errors.addAll(fieldValidation.errors.map((e) => '$fieldName: $e'));
        warnings.addAll(fieldValidation.warnings.map((w) => '$fieldName: $w'));
      }
    }

    // Apply validation rules
    final ruleValidation = validationRules.validate(eventData);
    errors.addAll(ruleValidation.errors);
    warnings.addAll(ruleValidation.warnings);

    return EventValidationResult(
      isValid: errors.isEmpty,
      errors: errors,
      warnings: warnings,
      eventName: name,
    );
  }

  /// Calculate event data size
  int calculateEventSize(Map<String, dynamic> eventData) {
    int totalSize = discriminator?.length ?? 0; // Discriminator size

    for (final field in fields) {
      if (eventData.containsKey(field.name)) {
        totalSize += field.calculateFieldSize(eventData[field.name]);
      } else if (field.hasDefaultValue) {
        totalSize += field.calculateFieldSize(field.defaultValue);
      }
    }

    return totalSize;
  }

  /// Check if event is compatible with another definition (for inheritance/versioning)
  bool isCompatibleWith(EventDefinition other) {
    if (name != other.name) return false;

    // Check field compatibility
    for (final field in fields) {
      final otherField = other.fields.where((f) => f.name == field.name).firstOrNull;
      if (otherField == null) {
        // Field is missing in other definition
        if (field.isRequired) return false;
      } else {
        // Field exists, check type compatibility
        if (!field.typeInfo.isCompatibleWith(otherField.typeInfo)) {
          return false;
        }
      }
    }

    return true;
  }

  /// Generate event schema for external tools
  Map<String, dynamic> generateSchema() {
    return {
      'name': name,
      'docs': docs,
      'discriminator': discriminator,
      'fields': fields.map((f) => f.toSchemaMap()).toList(),
      'metadata': metadata.toMap(),
      'validationRules': validationRules.toMap(),
      'inheritance': inheritanceInfo?.toMap(),
      'version': versionInfo?.toMap(),
    };
  }

  static int _calculateEstimatedSize(List<EventFieldDefinition> fields) {
    return fields.fold(8, (sum, field) => sum + field.typeInfo.estimatedSize);
  }

  static EventComplexity _calculateComplexity(List<EventFieldDefinition> fields) {
    final complexFields = fields.where((f) => f.typeInfo.isComplex).length;
    final nestedFields = fields.where((f) => f.typeInfo.hasNestedStructures).length;
    
    if (nestedFields > 3 || complexFields > 5) return EventComplexity.high;
    if (nestedFields > 1 || complexFields > 2) return EventComplexity.medium;
    return EventComplexity.low;
  }

  static List<String> _extractTags(List<String>? docs) {
    if (docs == null) return [];
    
    final tags = <String>[];
    for (final doc in docs) {
      final tagMatch = RegExp(r'@(\w+)').allMatches(doc);
      tags.addAll(tagMatch.map((m) => m.group(1)!));
    }
    return tags;
  }

  static EventInheritanceInfo? _parseInheritanceInfo(List<String>? docs) {
    if (docs == null) return null;
    
    for (final doc in docs) {
      final inheritanceMatch = RegExp(r'@inherits\s+(\w+)').firstMatch(doc);
      if (inheritanceMatch != null) {
        return EventInheritanceInfo(
          parentEvent: inheritanceMatch.group(1)!,
          inheritanceType: EventInheritanceType.extendsType,
        );
      }
      
      final compositionMatch = RegExp(r'@composes\s+(\w+)').firstMatch(doc);
      if (compositionMatch != null) {
        return EventInheritanceInfo(
          parentEvent: compositionMatch.group(1)!,
          inheritanceType: EventInheritanceType.composes,
        );
      }
    }
    
    return null;
  }

  static EventVersionInfo? _parseVersionInfo(List<String>? docs) {
    if (docs == null) return null;
    
    for (final doc in docs) {
      final versionMatch = RegExp(r'@version\s+(\d+)\.(\d+)\.?(\d+)?').firstMatch(doc);
      if (versionMatch != null) {
        return EventVersionInfo(
          major: int.parse(versionMatch.group(1)!),
          minor: int.parse(versionMatch.group(2)!),
          patch: versionMatch.group(3) != null ? int.parse(versionMatch.group(3)!) : 0,
        );
      }
    }
    
    return null;
  }

  @override
  String toString() => 'EventDefinition(name: $name, fields: ${fields.length})';
}

/// Event field definition with comprehensive type information
class EventFieldDefinition {
  /// Field name
  final String name;

  /// Field documentation
  final List<String>? docs;

  /// Field type information
  final EventFieldTypeInfo typeInfo;

  /// Whether field is optional
  final bool isOptional;

  /// Whether field is required
  bool get isRequired => !isOptional;

  /// Field constraints
  final List<EventFieldConstraint> constraints;

  /// Default value (if any)
  final dynamic defaultValue;

  /// Whether field has a default value
  bool get hasDefaultValue => defaultValue != null;

  const EventFieldDefinition({
    required this.name,
    this.docs,
    required this.typeInfo,
    this.isOptional = false,
    this.constraints = const [],
    this.defaultValue,
  });

  /// Create from IDL field
  factory EventFieldDefinition.fromIdlField(IdlField idlField, {
    Map<String, IdlTypeDef>? customTypes,
  }) {
    final typeInfo = EventFieldTypeInfo.fromIdlType(idlField.type, customTypes: customTypes);
    final isOptional = typeInfo.isOptional;
    final constraints = _parseConstraints(idlField.docs);

    return EventFieldDefinition(
      name: idlField.name,
      docs: idlField.docs,
      typeInfo: typeInfo,
      isOptional: isOptional,
      constraints: constraints,
      defaultValue: _parseDefaultValue(idlField.docs, typeInfo),
    );
  }

  /// Validate field value
  EventFieldValidationResult validateValue(dynamic value) {
    final errors = <String>[];
    final warnings = <String>[];

    // Type validation
    if (!typeInfo.isValidValue(value)) {
      errors.add('Invalid type for field $name: expected ${typeInfo.typeName}, got ${value.runtimeType}');
      return EventFieldValidationResult(
        isValid: false,
        errors: errors,
        warnings: warnings,
      );
    }

    // Constraint validation
    for (final constraint in constraints) {
      final result = constraint.validate(value);
      if (!result.isValid) {
        errors.addAll(result.errors);
        warnings.addAll(result.warnings);
      }
    }

    return EventFieldValidationResult(
      isValid: errors.isEmpty,
      errors: errors,
      warnings: warnings,
    );
  }

  /// Calculate field size for given value
  int calculateFieldSize(dynamic value) {
    return typeInfo.calculateSize(value);
  }

  /// Convert to schema map
  Map<String, dynamic> toSchemaMap() {
    return {
      'name': name,
      'docs': docs,
      'type': typeInfo.toMap(),
      'optional': isOptional,
      'constraints': constraints.map((c) => c.toMap()).toList(),
      'defaultValue': defaultValue,
    };
  }

  static List<EventFieldConstraint> _parseConstraints(List<String>? docs) {
    if (docs == null) return [];
    
    final constraints = <EventFieldConstraint>[];
    for (final doc in docs) {
      // Parse @min constraint
      final minMatch = RegExp(r'@min\s+(\d+)').firstMatch(doc);
      if (minMatch != null) {
        constraints.add(EventFieldConstraint.min(int.parse(minMatch.group(1)!)));
      }
      
      // Parse @max constraint
      final maxMatch = RegExp(r'@max\s+(\d+)').firstMatch(doc);
      if (maxMatch != null) {
        constraints.add(EventFieldConstraint.max(int.parse(maxMatch.group(1)!)));
      }
      
      // Parse @length constraint
      final lengthMatch = RegExp(r'@length\s+(\d+)').firstMatch(doc);
      if (lengthMatch != null) {
        constraints.add(EventFieldConstraint.length(int.parse(lengthMatch.group(1)!)));
      }
    }
    
    return constraints;
  }

  static dynamic _parseDefaultValue(List<String>? docs, EventFieldTypeInfo typeInfo) {
    if (docs == null) return null;
    
    for (final doc in docs) {
      final defaultMatch = RegExp(r'@default\s+(.+)').firstMatch(doc);
      if (defaultMatch != null) {
        final defaultStr = defaultMatch.group(1)!.trim();
        return typeInfo.parseValue(defaultStr);
      }
    }
    
    return null;
  }

  @override
  String toString() => 'EventFieldDefinition(name: $name, type: ${typeInfo.typeName})';
}

/// Comprehensive type information for event fields
class EventFieldTypeInfo {
  /// Type name
  final String typeName;

  /// Whether type is primitive (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, bool, string)
  final bool isPrimitive;

  /// Whether type is complex (array, vector, option, struct, enum)
  final bool isComplex;

  /// Whether type is optional
  final bool isOptional;

  /// Whether type has nested structures
  final bool hasNestedStructures;

  /// Estimated size in bytes
  final int estimatedSize;

  /// Type parameters (for generic types)
  final List<EventFieldTypeInfo>? typeParameters;

  /// Type constraints
  final Map<String, dynamic> constraints;

  const EventFieldTypeInfo({
    required this.typeName,
    required this.isPrimitive,
    required this.isComplex,
    required this.isOptional,
    required this.hasNestedStructures,
    required this.estimatedSize,
    this.typeParameters,
    this.constraints = const {},
  });

  /// Create from IDL type
  factory EventFieldTypeInfo.fromIdlType(IdlType idlType, {
    Map<String, IdlTypeDef>? customTypes,
  }) {
    return _parseIdlType(idlType, customTypes ?? {});
  }

  static EventFieldTypeInfo _parseIdlType(IdlType idlType, Map<String, IdlTypeDef> customTypes) {
    // Handle simple types first
    switch (idlType.kind) {
      case 'bool':
      case 'u8':
      case 'i8':
      case 'u16':
      case 'i16':
      case 'u32':
      case 'i32':
      case 'f32':
      case 'u64':
      case 'i64':
      case 'f64':
      case 'u128':
      case 'i128':
      case 'string':
      case 'pubkey':
        return _parsePrimitiveType(idlType.kind);

      case 'option':
        if (idlType.inner != null) {
          final innerType = _parseIdlType(idlType.inner!, customTypes);
          return EventFieldTypeInfo(
            typeName: 'Option<${innerType.typeName}>',
            isPrimitive: false,
            isComplex: true,
            isOptional: true,
            hasNestedStructures: innerType.hasNestedStructures,
            estimatedSize: innerType.estimatedSize + 1, // +1 for option discriminator
            typeParameters: [innerType],
          );
        }
        break;

      case 'vec':
        if (idlType.inner != null) {
          final innerType = _parseIdlType(idlType.inner!, customTypes);
          return EventFieldTypeInfo(
            typeName: 'Vec<${innerType.typeName}>',
            isPrimitive: false,
            isComplex: true,
            isOptional: false,
            hasNestedStructures: true,
            estimatedSize: 4 + (innerType.estimatedSize * 4), // 4 bytes for length + estimated content
            typeParameters: [innerType],
          );
        }
        break;

      case 'array':
        if (idlType.inner != null && idlType.size != null) {
          final innerType = _parseIdlType(idlType.inner!, customTypes);
          final size = idlType.size!;
          return EventFieldTypeInfo(
            typeName: '[${innerType.typeName}; $size]',
            isPrimitive: false,
            isComplex: true,
            isOptional: false,
            hasNestedStructures: innerType.hasNestedStructures || size > 1,
            estimatedSize: innerType.estimatedSize * size,
            typeParameters: [innerType],
            constraints: {'arraySize': size},
          );
        }
        break;

      case 'defined':
        if (idlType.defined != null) {
          final typeName = idlType.defined!;
          final customType = customTypes[typeName];
          if (customType != null) {
            // Parse custom type definition
            return _parseCustomType(customType, customTypes);
          }
          
          return EventFieldTypeInfo(
            typeName: typeName,
            isPrimitive: false,
            isComplex: true,
            isOptional: false,
            hasNestedStructures: true,
            estimatedSize: 32, // Estimated size for unknown custom types
          );
        }
        break;

      default:
        return EventFieldTypeInfo(
          typeName: idlType.kind,
          isPrimitive: false,
          isComplex: true,
          isOptional: false,
          hasNestedStructures: false,
          estimatedSize: 8, // Default estimate
        );
    }

    return EventFieldTypeInfo(
      typeName: 'unknown',
      isPrimitive: false,
      isComplex: false,
      isOptional: false,
      hasNestedStructures: false,
      estimatedSize: 0,
    );
  }

  static EventFieldTypeInfo _parsePrimitiveType(String typeName) {
    switch (typeName) {
      case 'bool':
        return const EventFieldTypeInfo(
          typeName: 'bool',
          isPrimitive: true,
          isComplex: false,
          isOptional: false,
          hasNestedStructures: false,
          estimatedSize: 1,
        );
      case 'u8':
      case 'i8':
        return EventFieldTypeInfo(
          typeName: typeName,
          isPrimitive: true,
          isComplex: false,
          isOptional: false,
          hasNestedStructures: false,
          estimatedSize: 1,
        );
      case 'u16':
      case 'i16':
        return EventFieldTypeInfo(
          typeName: typeName,
          isPrimitive: true,
          isComplex: false,
          isOptional: false,
          hasNestedStructures: false,
          estimatedSize: 2,
        );
      case 'u32':
      case 'i32':
      case 'f32':
        return EventFieldTypeInfo(
          typeName: typeName,
          isPrimitive: true,
          isComplex: false,
          isOptional: false,
          hasNestedStructures: false,
          estimatedSize: 4,
        );
      case 'u64':
      case 'i64':
      case 'f64':
        return EventFieldTypeInfo(
          typeName: typeName,
          isPrimitive: true,
          isComplex: false,
          isOptional: false,
          hasNestedStructures: false,
          estimatedSize: 8,
        );
      case 'u128':
      case 'i128':
        return EventFieldTypeInfo(
          typeName: typeName,
          isPrimitive: true,
          isComplex: false,
          isOptional: false,
          hasNestedStructures: false,
          estimatedSize: 16,
        );
      case 'string':
        return const EventFieldTypeInfo(
          typeName: 'string',
          isPrimitive: true,
          isComplex: false,
          isOptional: false,
          hasNestedStructures: false,
          estimatedSize: 36, // 4 bytes for length + estimated 32 chars
        );
      case 'publicKey':
        return const EventFieldTypeInfo(
          typeName: 'publicKey',
          isPrimitive: true,
          isComplex: false,
          isOptional: false,
          hasNestedStructures: false,
          estimatedSize: 32,
        );
      default:
        return EventFieldTypeInfo(
          typeName: typeName,
          isPrimitive: false,
          isComplex: false,
          isOptional: false,
          hasNestedStructures: false,
          estimatedSize: 8, // Default estimate
        );
    }
  }

  static EventFieldTypeInfo _parseCustomType(IdlTypeDef typeDef, Map<String, IdlTypeDef> customTypes) {
    // Handle struct types by calculating estimated size from fields
    if (typeDef.type.kind == 'struct' && typeDef.type.fields != null) {
      int totalSize = 0;
      bool hasNested = false;
      
      for (final field in typeDef.type.fields!) {
        final fieldType = _parseIdlType(field.type, customTypes);
        totalSize += fieldType.estimatedSize;
        if (fieldType.hasNestedStructures) hasNested = true;
      }
      
      return EventFieldTypeInfo(
        typeName: typeDef.name,
        isPrimitive: false,
        isComplex: true,
        isOptional: false,
        hasNestedStructures: hasNested,
        estimatedSize: totalSize,
      );
    }
    
    return EventFieldTypeInfo(
      typeName: typeDef.name,
      isPrimitive: false,
      isComplex: true,
      isOptional: false,
      hasNestedStructures: true,
      estimatedSize: 32, // Default estimate for custom types
    );
  }

  /// Check if a value is valid for this type
  bool isValidValue(dynamic value) {
    switch (typeName) {
      case 'bool':
        return value is bool;
      case 'u8':
      case 'u16':
      case 'u32':
      case 'u64':
      case 'u128':
        return value is int && value >= 0;
      case 'i8':
      case 'i16':
      case 'i32':
      case 'i64':
      case 'i128':
        return value is int;
      case 'f32':
      case 'f64':
        return value is num;
      case 'string':
        return value is String;
      case 'publicKey':
        return value is String || value is PublicKey;
      default:
        if (typeName.startsWith('Option<')) {
          if (value == null) return true;
          // For Option types, validate against the inner type
          final innerTypeName = typeName.substring(7, typeName.length - 1); // Remove 'Option<' and '>'
          final innerTypeInfo = EventFieldTypeInfo(
            typeName: innerTypeName,
            isPrimitive: typeParameters?.first.isPrimitive ?? false,
            isComplex: typeParameters?.first.isComplex ?? false,
            isOptional: false,
            hasNestedStructures: typeParameters?.first.hasNestedStructures ?? false,
            estimatedSize: typeParameters?.first.estimatedSize ?? 0,
          );
          return innerTypeInfo.isValidValue(value);
        }
        if (typeName.startsWith('Vec<')) {
          return value is List;
        }
        if (typeName.contains('[') && typeName.contains(';')) {
          return value is List;
        }
        return true; // For complex/custom types, assume valid for now
    }
  }

  /// Calculate size for a specific value
  int calculateSize(dynamic value) {
    if (typeName.startsWith('Vec<')) {
      if (value is List) {
        final innerType = typeParameters?.first;
        if (innerType != null) {
          int totalSize = 4; // Vector length
          for (final item in value) {
            totalSize += innerType.calculateSize(item);
          }
          return totalSize;
        }
      }
      return estimatedSize;
    }
    
    if (typeName == 'string' && value is String) {
      return 4 + value.length; // 4 bytes for length + string bytes
    }
    
    return estimatedSize;
  }

  /// Parse value from string representation
  dynamic parseValue(String valueStr) {
    switch (typeName) {
      case 'bool':
        return valueStr.toLowerCase() == 'true';
      case 'u8':
      case 'u16':
      case 'u32':
      case 'u64':
      case 'u128':
      case 'i8':
      case 'i16':
      case 'i32':
      case 'i64':
      case 'i128':
        return int.tryParse(valueStr);
      case 'f32':
      case 'f64':
        return double.tryParse(valueStr);
      case 'string':
        return valueStr.replaceAll('"', '');
      case 'publicKey':
        return valueStr;
      default:
        return valueStr;
    }
  }

  /// Check compatibility with another type
  bool isCompatibleWith(EventFieldTypeInfo other) {
    if (typeName == other.typeName) return true;
    
    // Check numeric type compatibility
    const numericTypes = [
      'u8', 'u16', 'u32', 'u64', 'u128',
      'i8', 'i16', 'i32', 'i64', 'i128',
      'f32', 'f64'
    ];
    
    if (numericTypes.contains(typeName) && numericTypes.contains(other.typeName)) {
      return true; // Numeric types are generally compatible
    }
    
    return false;
  }

  /// Convert to map representation
  Map<String, dynamic> toMap() {
    return {
      'typeName': typeName,
      'isPrimitive': isPrimitive,
      'isComplex': isComplex,
      'isOptional': isOptional,
      'hasNestedStructures': hasNestedStructures,
      'estimatedSize': estimatedSize,
      'typeParameters': typeParameters?.map((t) => t.toMap()).toList(),
      'constraints': constraints,
    };
  }

  @override
  String toString() => 'EventFieldTypeInfo(type: $typeName)';
}

/// Event metadata for validation and processing
class EventMetadata {
  /// Total number of fields
  final int totalFields;

  /// Whether event has optional fields
  final bool hasOptionalFields;

  /// Whether event has nested structures
  final bool hasNestedStructures;

  /// Estimated event size in bytes
  final int estimatedSize;

  /// Event complexity level
  final EventComplexity complexity;

  /// Event tags (parsed from documentation)
  final List<String> tags;

  const EventMetadata({
    required this.totalFields,
    required this.hasOptionalFields,
    required this.hasNestedStructures,
    required this.estimatedSize,
    required this.complexity,
    this.tags = const [],
  });

  /// Convert to map representation
  Map<String, dynamic> toMap() {
    return {
      'totalFields': totalFields,
      'hasOptionalFields': hasOptionalFields,
      'hasNestedStructures': hasNestedStructures,
      'estimatedSize': estimatedSize,
      'complexity': complexity.toString(),
      'tags': tags,
    };
  }
}

/// Event complexity levels
enum EventComplexity {
  low,
  medium,
  high,
}

/// Event validation rules
class EventValidationRules {
  /// Required field validation
  final bool enforceRequiredFields;

  /// Type validation strictness
  final TypeValidationStrictness typeStrictness;

  /// Maximum allowed event size
  final int? maxEventSize;

  /// Field constraints validation
  final bool enforceFieldConstraints;

  /// Custom validation functions
  final List<EventValidator> customValidators;

  const EventValidationRules({
    this.enforceRequiredFields = true,
    this.typeStrictness = TypeValidationStrictness.strict,
    this.maxEventSize,
    this.enforceFieldConstraints = true,
    this.customValidators = const [],
  });

  /// Create from fields
  factory EventValidationRules.fromFields(
    List<EventFieldDefinition> fields, {
    EventDefinitionConfig? config,
  }) {
    config ??= EventDefinitionConfig.defaultConfig();
    
    final hasRequiredFields = fields.any((f) => f.isRequired);
    final hasConstraints = fields.any((f) => f.constraints.isNotEmpty);
    final estimatedSize = fields.fold(0, (sum, field) => sum + field.typeInfo.estimatedSize);
    
    return EventValidationRules(
      enforceRequiredFields: hasRequiredFields && config.enforceRequiredFields,
      typeStrictness: config.typeStrictness,
      maxEventSize: config.maxEventSize ?? (estimatedSize > 1024 ? estimatedSize * 2 : null),
      enforceFieldConstraints: hasConstraints && config.enforceFieldConstraints,
    );
  }

  /// Validate event data
  EventValidationResult validate(Map<String, dynamic> eventData) {
    final errors = <String>[];
    final warnings = <String>[];

    // Size validation
    if (maxEventSize != null) {
      // Rough size estimation based on JSON serialization
      final jsonStr = eventData.toString();
      if (jsonStr.length > maxEventSize!) {
        errors.add('Event data size exceeds maximum allowed size: ${jsonStr.length} > $maxEventSize');
      }
    }

    // Custom validator execution
    for (final validator in customValidators) {
      final result = validator.validate(eventData);
      errors.addAll(result.errors);
      warnings.addAll(result.warnings);
    }

    return EventValidationResult(
      isValid: errors.isEmpty,
      errors: errors,
      warnings: warnings,
    );
  }

  /// Convert to map representation
  Map<String, dynamic> toMap() {
    return {
      'enforceRequiredFields': enforceRequiredFields,
      'typeStrictness': typeStrictness.toString(),
      'maxEventSize': maxEventSize,
      'enforceFieldConstraints': enforceFieldConstraints,
      'customValidators': customValidators.length,
    };
  }
}

/// Type validation strictness levels
enum TypeValidationStrictness {
  strict,
  lenient,
  disabled,
}

/// Event inheritance information
class EventInheritanceInfo {
  /// Parent event name
  final String parentEvent;

  /// Type of inheritance
  final EventInheritanceType inheritanceType;

  /// Additional inheritance metadata
  final Map<String, dynamic>? metadata;

  const EventInheritanceInfo({
    required this.parentEvent,
    required this.inheritanceType,
    this.metadata,
  });

  /// Convert to map representation
  Map<String, dynamic> toMap() {
    return {
      'parentEvent': parentEvent,
      'inheritanceType': inheritanceType.toString(),
      'metadata': metadata,
    };
  }
}

/// Event inheritance types
enum EventInheritanceType {
  extendsType,
  composes,
  implementsType,
}

/// Event version information
class EventVersionInfo {
  /// Major version
  final int major;

  /// Minor version
  final int minor;

  /// Patch version
  final int patch;

  /// Version metadata
  final Map<String, dynamic>? metadata;

  const EventVersionInfo({
    required this.major,
    required this.minor,
    required this.patch,
    this.metadata,
  });

  /// Version string representation
  String get versionString => '$major.$minor.$patch';

  /// Check if this version is compatible with another
  bool isCompatibleWith(EventVersionInfo other) {
    // Major version must match for compatibility
    if (major != other.major) return false;
    
    // Minor version backwards compatibility
    return minor >= other.minor;
  }

  /// Convert to map representation
  Map<String, dynamic> toMap() {
    return {
      'major': major,
      'minor': minor,
      'patch': patch,
      'versionString': versionString,
      'metadata': metadata,
    };
  }
}

/// Event field constraint
class EventFieldConstraint {
  /// Constraint type
  final EventConstraintType type;

  /// Constraint value
  final dynamic value;

  /// Constraint metadata
  final Map<String, dynamic>? metadata;

  const EventFieldConstraint({
    required this.type,
    required this.value,
    this.metadata,
  });

  /// Create minimum value constraint
  factory EventFieldConstraint.min(num minValue) {
    return EventFieldConstraint(
      type: EventConstraintType.min,
      value: minValue,
    );
  }

  /// Create maximum value constraint
  factory EventFieldConstraint.max(num maxValue) {
    return EventFieldConstraint(
      type: EventConstraintType.max,
      value: maxValue,
    );
  }

  /// Create length constraint
  factory EventFieldConstraint.length(int length) {
    return EventFieldConstraint(
      type: EventConstraintType.length,
      value: length,
    );
  }

  /// Create range constraint
  factory EventFieldConstraint.range(num min, num max) {
    return EventFieldConstraint(
      type: EventConstraintType.range,
      value: [min, max],
    );
  }

  /// Validate constraint
  EventFieldValidationResult validate(dynamic fieldValue) {
    final errors = <String>[];
    final warnings = <String>[];

    switch (type) {
      case EventConstraintType.min:
        if (fieldValue is num && fieldValue < (value as num)) {
          errors.add('Value $fieldValue is less than minimum $value');
        }
        break;
      case EventConstraintType.max:
        if (fieldValue is num && fieldValue > (value as num)) {
          errors.add('Value $fieldValue is greater than maximum $value');
        }
        break;
      case EventConstraintType.length:
        if (fieldValue is String && fieldValue.length != (value as int)) {
          errors.add('String length ${fieldValue.length} does not match required length $value');
        } else if (fieldValue is List && fieldValue.length != (value as int)) {
          errors.add('Array length ${fieldValue.length} does not match required length $value');
        }
        break;
      case EventConstraintType.range:
        final range = value as List<num>;
        if (fieldValue is num && (fieldValue < range[0] || fieldValue > range[1])) {
          errors.add('Value $fieldValue is not in range [${range[0]}, ${range[1]}]');
        }
        break;
      case EventConstraintType.custom:
        // Custom constraints would be handled by custom validators
        break;
    }

    return EventFieldValidationResult(
      isValid: errors.isEmpty,
      errors: errors,
      warnings: warnings,
    );
  }

  /// Convert to map representation
  Map<String, dynamic> toMap() {
    return {
      'type': type.toString(),
      'value': value,
      'metadata': metadata,
    };
  }
}

/// Event constraint types
enum EventConstraintType {
  min,
  max,
  length,
  range,
  custom,
}

/// Event validation result
class EventValidationResult {
  /// Whether validation passed
  final bool isValid;

  /// Validation errors
  final List<String> errors;

  /// Validation warnings
  final List<String> warnings;

  /// Event name (for context)
  final String? eventName;

  const EventValidationResult({
    required this.isValid,
    this.errors = const [],
    this.warnings = const [],
    this.eventName,
  });
}

/// Event field validation result
class EventFieldValidationResult {
  /// Whether validation passed
  final bool isValid;

  /// Validation errors
  final List<String> errors;

  /// Validation warnings
  final List<String> warnings;

  const EventFieldValidationResult({
    required this.isValid,
    this.errors = const [],
    this.warnings = const [],
  });
}

/// Custom event validator interface
abstract class EventValidator {
  /// Validate event data
  EventValidationResult validate(Map<String, dynamic> eventData);
}

/// Event definition configuration
class EventDefinitionConfig {
  /// Whether to automatically generate discriminators
  final bool autoGenerateDiscriminator;

  /// Whether to enforce required fields
  final bool enforceRequiredFields;

  /// Type validation strictness
  final TypeValidationStrictness typeStrictness;

  /// Maximum allowed event size
  final int? maxEventSize;

  /// Whether to enforce field constraints
  final bool enforceFieldConstraints;

  /// Whether to enable inheritance support
  final bool enableInheritance;

  /// Whether to enable versioning support
  final bool enableVersioning;

  const EventDefinitionConfig({
    this.autoGenerateDiscriminator = true,
    this.enforceRequiredFields = true,
    this.typeStrictness = TypeValidationStrictness.strict,
    this.maxEventSize,
    this.enforceFieldConstraints = true,
    this.enableInheritance = true,
    this.enableVersioning = true,
  });

  /// Default configuration
  factory EventDefinitionConfig.defaultConfig() {
    return const EventDefinitionConfig();
  }

  /// Lenient configuration for development
  factory EventDefinitionConfig.lenient() {
    return const EventDefinitionConfig(
      typeStrictness: TypeValidationStrictness.lenient,
      enforceRequiredFields: false,
      enforceFieldConstraints: false,
    );
  }

  /// Strict configuration for production
  factory EventDefinitionConfig.strict() {
    return const EventDefinitionConfig(
      typeStrictness: TypeValidationStrictness.strict,
      enforceRequiredFields: true,
      enforceFieldConstraints: true,
      maxEventSize: 2048,
    );
  }
}

/// IDL event parser utility
class IdlEventParser {
  /// Parse events from IDL with comprehensive analysis
  static List<EventDefinition> parseEvents(
    List<IdlEvent> idlEvents, {
    Map<String, IdlTypeDef>? customTypes,
    EventDefinitionConfig? config,
  }) {
    config ??= EventDefinitionConfig.defaultConfig();
    customTypes ??= {};

    final events = <EventDefinition>[];
    
    for (final idlEvent in idlEvents) {
      try {
        final eventDef = EventDefinition.fromIdl(
          idlEvent,
          customTypes: customTypes,
          config: config,
        );
        events.add(eventDef);
      } catch (e) {
        throw EventDefinitionException(
          'Failed to parse event ${idlEvent.name}: $e',
          eventName: idlEvent.name,
        );
      }
    }

    // Validate event inheritance relationships
    if (config.enableInheritance) {
      _validateInheritanceRelationships(events);
    }

    return events;
  }

  static void _validateInheritanceRelationships(List<EventDefinition> events) {
    final eventMap = {for (final event in events) event.name: event};
    
    for (final event in events) {
      if (event.inheritanceInfo != null) {
        final parentName = event.inheritanceInfo!.parentEvent;
        final parent = eventMap[parentName];
        
        if (parent == null) {
          throw EventDefinitionException(
            'Parent event $parentName not found for event ${event.name}',
            eventName: event.name,
          );
        }
        
        // Check compatibility
        if (!event.isCompatibleWith(parent)) {
          throw EventDefinitionException(
            'Event ${event.name} is not compatible with parent event $parentName',
            eventName: event.name,
          );
        }
      }
    }
  }
}

/// Event definition exception
class EventDefinitionException implements Exception {
  /// Error message
  final String message;

  /// Event name (for context)
  final String? eventName;

  const EventDefinitionException(this.message, {this.eventName});

  @override
  String toString() {
    return eventName != null 
        ? 'EventDefinitionException ($eventName): $message'
        : 'EventDefinitionException: $message';
  }
}
